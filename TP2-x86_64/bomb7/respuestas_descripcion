Nombre: Mateo Bramer Markovic
Mail: bramermarkovicm@udesa.edu.ar
--------------------------------------------------------------------------------------------------------------------------
fase 1:

lea    rsi,[rip+0xc7c62]   # 0x4c9a58 
call   0x402311 <strings_not_equal>
lee lo que está en # 0x4c9a58 y lo compara con lo que yo le pase
por ende busco lo que está en # 0x4c9a58 

x/s 0x4c9a58 : La ingratitud es hija de la soberbia.

--------------------------------------------------------------------------------------------------------------------------

Fase 2;

mov eax, ebx      
imul eax, ebp     
test eax, eax       
je explode_bomb     ; si a * b == 0 → explota

a y b son números y no pueden ser 0 ninguno

add ebx, ebp        
cmp ebx, 0x5d47     
jne explode_bomb

la suma de a y b tiene que ser 0x5d47, en decimal 23879
Ahora entra a una función misterio
xor    edi,edi
js     0x401e21 <misterio+22>

si xor edi, edi es negativo no explota la bomba.
entonces a xor b también tiene que ser negativo

Entonces se que mi input son dos numeros, a b
Ninguno puede ser 0 
a xor b = negativo 
Un par posible es a = -1, b = 23880

----------------------------------------------------------------------------------------------------------------------

Fase 3:
lea    rsi,[rip+0xc502b]        # 0x4c7099
me fijo lo que está en  # 0x4c7099
0x4c7099:       "%s %d"

cmp    DWORD PTR [rsp+0x14], 0x6 
jle    0x402121  

si mi segundo input es menor que 6, explota

mi primer input es una string y el segundo un entero mayor estricto que 6

entro a ver la función readlines
lea    rsi,[rip+0xc5846]        # 0x4c7723
lea    rdi,[rip+0xc51a8]        # 0x4c708c
call   0x410b00 <fopen64>
me fijo que hay en  # 0x4c7723 y # 0x4c708c

esto me da:
r, palabras.txt
entonces lee el archivo palabras.txt

Ahora me fijo que está en la función Cuenta

xor ebx, ecx       
sar ebx, 1         
and eax, ecx       
add ebx, eax       

Esto se usa para calcular el punto medio de dos números (busqueda binaria)

mov eax, DWORD PTR [r8]  
add eax,0x1
cmp eax,0xb              
jg  explode_bomb

Va actualizando un contador y si se pasa de 11 explota

mov rsi, [r15 + rbx*8]  
mov rdi, r14           
call strcmp
busca el punto medio de palabras.txt y lo compara con lo que yo pase, si son iguales sale

La clave de fase 3 termina siendo dos parámetros , A - B. A debe ser una palabra que está dentro del archivo palabras.txt y B tiene que ser el numero de iteraciones que tarda en encontrar a “a” haciendo una busquedad binario sobre palabras.txt, y debe estar entre [7,11].

Otra cosa que hice para confirmar fue poner un breakpoint en 0x00000000004020b5 para ver como quedaba en memoria los valores de $rsp+0x14 y $rsp+0xc, al usar un ejemplo. En este caso use abajar 7 

   0x00000000004020b0 <+127>:   call   0x401f98 <cuenta>
   0x00000000004020b5 <+132>:   mov    eax,DWORD PTR [rsp+0xc]
   0x00000000004020b9 <+136>:   cmp    DWORD PTR [rsp+0x14],eax
   0x00000000004020bd <+140>:   jne    0x40211a <phase_3+233>

$rsp+0x14 = al numero que tiene que igualar mi input 
$rsp+0xc = mi input 

al final encontre que :
x/dw $rsp+0x14
0x7fffffffdb94: 11

x/dw $rsp+0xc
0x7fffffffdb8c: 7 (esto ya lo sabia pero para confirmar)

Entonces mi input deberia ser 11 cuando utilizo abajar

Tambien encontre un ejemplo haciendo una busquedad por mi cuenta por cada palabra en palabras.txt hasta encontrar una que funcione
Esto me dio, A = abajar, B = 11
--------------------------------------------------------------------------------------------------------------------------Fase 4:
0x000000000040214d <+32>:    lea    rsi,[rip+0xc4f98]        # 0x4c70ec
Similar a antes, lee lo que esta en 0x4c70ec
(gdb) x/s 0x4c70ec
0x4c70ec:       "%d %d"
Mi input debe ser 2 enteros

0x000000000040215e <+49>:    mov    eax, DWORD PTR [rsp]      
0x0000000000402161 <+52>:    and    eax, 0xf                   
0x0000000000402164 <+55>:    mov    DWORD PTR [rsp], eax       
0x0000000000402167 <+58>:    cmp    eax, 0xf                    
0x000000000040216a <+61>:    je     0x40219e <phase_4+113>     

Aca lo que pasa es que carga mi primer input y hace mod 16 y compara que no sea 15

0x000000000040216c <+63>:    mov    ecx, 0x0                 
0x0000000000402171 <+68>:    mov    edx, 0x0                 
0x0000000000402176 <+73>:    lea    rsi, [rip+0xcbca3]         # 0x4cde20 <array.0>

ecx va ser una suma
edx va ser un contador 
y lea la memoria de un array

0x000000000040217d <+80>:    add    edx, 0x1                  
0x0000000000402180 <+83>:    cdqe                              
0x0000000000402182 <+85>:    mov    eax, DWORD PTR [rsi+rax*4] 
0x0000000000402185 <+88>:    add    ecx, eax                  
0x0000000000402187 <+90>:    cmp    eax, 0xf                  
0x000000000040218a <+93>:    jne    0x40217d <phase_4+80>    
; --- FIN DEL BUCLE ---

Va sumando en ecx los valores de un array y va contando en edx 

Si el valor es 15 en el array sale del bucle

El bucle no va en forma lineal, agarra lo que esta en la posicion de mi primer input y ese numero mod 16 va ser el proximo lugar donde se va fijar en el array: mov    eax, DWORD PTR [rsi+rax*4] 

0x0000000000402193 <+102>:   cmp    edx, 0xa                 
0x0000000000402196 <+105>:   jne    0x40219e <phase_4+113>      
0x0000000000402198 <+107>:   cmp    DWORD PTR [rsp+0x4], ecx   
0x000000000040219c <+111>:   je     0x4021a3 <phase_4+118>     
0x000000000040219e <+113>:   call   0x40243a <explode_bomb>     

Se fija si mi contador es 10 y si la suma es igual a mi segundo input. Si no explota

Entonces tengo que encontrar dos numeros, A y B. A va terminar siendo un numero entre 0 y 14, porque hace mod 16 y 15 no puede ser.

Despues A tambien tiene que ser un numero en 10 iteraciones va a llegar a una posicion en donde mi array tenga el valor 15.

Intenando con cada posible valor me dio que si arranco en la posicion 5 en 10 iteraciones llego a una posicion del array que su valor sea 15

Esto me da A = 5 y B = 72